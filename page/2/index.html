<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Jimmy | iOS | develop | 移动">
<meta property="og:type" content="website">
<meta property="og:title" content="Jimmy&#39;Zone">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Jimmy&#39;Zone">
<meta property="og:description" content="Jimmy | iOS | develop | 移动">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jimmy&#39;Zone">
<meta name="twitter:description" content="Jimmy | iOS | develop | 移动">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Jimmy'Zone</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jimmy'Zone</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">态度决定一切，细节决定成败</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/04/2017-05-04-R.swift-的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JimmyZhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy'Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/04/2017-05-04-R.swift-的使用/" itemprop="url">R.swift 的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-04T00:00:00+08:00">
                2017-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="external">BY Blog</a>, 作者 <a href="http://github.com/qiubaiying" target="_blank" rel="external">@柏荧(BY)</a> ,转载请保留原文链接.</p>
</blockquote>
<h1 id="什么是-R-swift"><a href="#什么是-R-swift" class="headerlink" title="什么是 R.swift"></a>什么是 R.swift</h1><p>介绍 <a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="external">R.swift</a> 前，我们先看看 R.swift 能做什么</p>
<p>通常，我们是基于 字符串 来获取资源，例如：图片、xib、或者是 segue</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> myImage = <span class="type">UIImage</span>(named: <span class="string">"myImage"</span>)</div><div class="line"><span class="keyword">let</span> myViewController = <span class="type">R</span>.storyboard.main.myViewController()</div></pre></td></tr></table></figure>
<p>使用 R.swfit，我们可以这样写</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> myImage = <span class="type">R</span>.image.myImage()</div><div class="line"><span class="keyword">let</span> viewController = <span class="type">R</span>.storyboard.main.myViewController()</div></pre></td></tr></table></figure>
<p>R.swift 通过扫描你的各种基于字符串命名的资源，创建一个使用类型来获取资源。</p>
<p>在保证类型安全的同时，也在自动补全的帮助下节省了大量的时间。</p>
<h1 id="导入-R-swift"><a href="#导入-R-swift" class="headerlink" title="导入 R.swift"></a>导入 R.swift</h1><p><a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="external">R.swift</a> 开源在 github 上。</p>
<p>这里是导入的<a href="https://vimeo.com/122888912" target="_blank" rel="external">视频教程</a></p>
<p>使用 CocoaPods 导入项目中</p>
<ol>
<li>添加 <code>pod &#39;R.swift&#39;</code>到 Podfile 文件，然后运行 <code>pod install</code></li>
<li><p>添加一个 <code>New Run Script Phase</code></p>
<p> <img src="https://ww4.sinaimg.cn/large/006tKfTcgy1ff84sw06qxj30vm0hrq6s.jpg" alt=""></p>
</li>
<li><p>将 <code>Run Script</code> 拖动到 <code>Check Pods Manifest.lock</code> 的下面，并且添加脚本 <code>&quot;$PODS_ROOT/R.swift/rswift&quot; &quot;$SRCROOT/项目名称&quot;</code></p>
<p> <img src="https://ww4.sinaimg.cn/large/006tNc79gy1ff853qjiucj30yp0kkn1b.jpg" alt=""></p>
</li>
<li><p><code>Command+B</code> 编译项目，在项目代码目录下，会生成一个 <code>R.generated.swift</code> 的文件，将它拖如项目中</p>
<blockquote>
<p>注意：不要勾选 <code>Copy items if needed</code> 选项，因为每次编译都会生成新的 <code>R.generated.swift</code> 文件，copy 的话，旧的 <code>R.generated.swift</code> 将不会被覆盖。</p>
</blockquote>
<p> <img src="https://ww4.sinaimg.cn/large/006tNc79gy1ff85epj1qpj30qj0hdn17.jpg" alt=""></p>
</li>
</ol>
<blockquote>
<p>tip： 可以在添加 <code>.gitignore</code> 添加一行 <code>*.generated.swift</code> 忽略该文件，避免造成冲突</p>
</blockquote>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>导入完成后，就可以在使用 R.swift 了</p>
<p> <img src="https://github.com/mac-cain13/R.swift/raw/master/Documentation/Images/DemoUseImage.gif" alt=""> </p>
<p>关于 R.swift 的更多用法，可以 <a href="https://github.com/mac-cain13/R.swift/blob/master/Documentation/Examples.md" target="_blank" rel="external">看这里</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/2017-05-03-Swift-的懒加载和计算型属性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JimmyZhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy'Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/03/2017-05-03-Swift-的懒加载和计算型属性/" itemprop="url">Swift 的懒加载和计算型属性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T00:00:00+08:00">
                2017-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="external">BY Blog</a>, 作者 <a href="http://github.com/qiubaiying" target="_blank" rel="external">@柏荧(BY)</a> ,转载请保留原文链接.</p>
</blockquote>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>常规（简化）写法</p>
<p>懒加载的属性用 <code>var</code> 声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lazy var name: String = &#123;</div><div class="line">	return &quot;BY&quot;</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>完整写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lazy var name: String = &#123; () -&gt; String i</div><div class="line">	return &quot;BY&quot;</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>本质是一个创建一个闭包 <code>{}</code> 并且在调用该属性时执行闭包 <code>()</code>。</p>
<p>如OC的懒加载不同的是 swift 懒加载闭包只调用一次，再次调用该属性时因为属性已经创建，不再执行闭包。</p>
<h3 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h3><p>常规写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var name: string &#123;</div><div class="line">	return &quot;BY&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整写法 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var name: string &#123;</div><div class="line">	get &#123;</div><div class="line">		return &quot;BY&quot;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>计算型属性本质是重写了 <code>get</code> 方法，其类似一个无参有返回值函数，每次调用该属性都会执行 <code>return</code></p>
<p>通常这样使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct Cuboid &#123;</div><div class="line">    var width = 0.0, height = 0.0, depth = 0.0</div><div class="line">    var volume: Double &#123;</div><div class="line">        return width * height * depth</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)</div><div class="line">print(&quot;the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)&quot;)</div><div class="line">// Prints &quot;the volume of fourByFiveByTwo is 40.0&quot;</div></pre></td></tr></table></figure>
<h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><p>相同点</p>
<ul>
<li>使用方法完全一致</li>
<li>都是用 <code>var</code> 声明</li>
</ul>
<p>不同点</p>
<ul>
<li><p>实现原理不同</p>
<p>  懒加载是第一次调用属性时执行闭包进行赋值</p>
<p>  计算型属性是重写 <code>get</code> 方法</p>
</li>
<li><p>调用 <code>{}</code>的次数不同</p>
<p>  懒加载的闭包只在属性第一次调用时执行<br>  计算型属性每次调用都要进入 <code>{}</code> 中，<code>return</code> 新的值</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/28/2017-04-28-RVM-使用指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JimmyZhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy'Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/28/2017-04-28-RVM-使用指南/" itemprop="url">RVM 使用指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-28T00:00:00+08:00">
                2017-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>RVM 常用的命令整理</p>
</blockquote>
<p>RVM 是一个命令行工具，可以提供一个便捷的多版本 Ruby 环境的管理和切换。<a href="https://rvm.io/" target="_blank" rel="external">https://rvm.io/</a></p>
<p>我相信做为iOS开发者，对ruby的使用都是从安装 <strong>CocoaPods</strong> 开始的吧~</p>
<blockquote>
<p><strong>Note</strong>：这里所有的命令都是再用户权限下操作的，任何命令最好都不要用 sudo.</p>
</blockquote>
<h2 id="RVM-安装"><a href="#RVM-安装" class="headerlink" title="RVM 安装"></a>RVM 安装</h2><pre><code>$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3
$ \curl -sSL https://get.rvm.io | bash -s stable
$ source ~/.bashrc
$ source ~/.bash_profile
</code></pre><p>修改 RVM 的 Ruby 安装源到 <a href="https://ruby-china.org/" target="_blank" rel="external">Ruby China</a> 的 Ruby 镜像服务器，这样能提高安装速度</p>
<pre><code>$ echo &quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot; &gt; ~/.rvm/user/db
</code></pre><h2 id="Ruby版本的安装与切换"><a href="#Ruby版本的安装与切换" class="headerlink" title="Ruby版本的安装与切换"></a>Ruby版本的安装与切换</h2><p>列出已知的 Ruby 版本</p>
<pre><code>rvm list known
</code></pre><p>安装一个 Ruby 版本</p>
<pre><code>rvm install 2.2.0 --disable-binary
</code></pre><p>切换 Ruby 版本</p>
<pre><code>rvm use 2.2.0
</code></pre><p>如果想设置为默认版本，这样一来以后新打开的控制台默认的 Ruby 就是这个版本</p>
<pre><code>rvm use 2.2.0 --default 
</code></pre><p>查询已经安装的ruby</p>
<pre><code>rvm list
</code></pre><p>卸载一个已安装版本</p>
<pre><code>rvm remove 1.8.7
</code></pre><blockquote>
<p>参考：<a href="https://ruby-china.org/wiki/rvm-guide" target="_blank" rel="external">https://ruby-china.org/wiki/rvm-guide</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/20/2017-04-20-iOS自动打包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JimmyZhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy'Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/20/2017-04-20-iOS自动打包/" itemprop="url">iOS自动打包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-20T00:00:00+08:00">
                2017-04-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>利用xcode的命令行工具 <code>xcdeobulid</code> 进行项目的编译打包，生成ipa包，并上传到fir</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在网上的自动打包教程几乎都还是<code>xcodebuild + xcrun</code>的方式先生成<code>.app</code>包 再生成<code>.ipa</code>包,结果弄了一整天硬是没成功~</p>
<p>后来发现<code>PackageApplication is deprecated</code>，悲剧。然后手动压缩的 <code>.ipa</code>包因为签名问题无法装到手机上。</p>
<p>后来用了<code>archive + -exportArchive</code>终于可以了~</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Xcodebuild"><a href="#Xcodebuild" class="headerlink" title="Xcodebuild"></a>Xcodebuild</h2><p><strong>xcodebuild</strong> 的使用可以用 <code>man xcodebuild</code>查看。</p>
<p>查看项目详情</p>
<pre><code># cd 项目主目录
xcodebuild -list
</code></pre><p>输出项目的信息</p>
<pre><code>Information about project &quot;StackGameSceneKit&quot;:
    Targets:
        StackGameSceneKit
        StackGameSceneKitTests

    Build Configurations:
        Debug
        Release

    If no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used.

    Schemes:
        StackGameSceneKit
</code></pre><p>要留意 <code>Configurations</code>，<code>Schemes</code>这两个属性。</p>
<h2 id="自动打包流程"><a href="#自动打包流程" class="headerlink" title="自动打包流程"></a>自动打包流程</h2><h3 id="生成-archive"><a href="#生成-archive" class="headerlink" title="生成 archive"></a>生成 archive</h3><p>生成archive的命令是 <code>xcodebuild archive</code> </p>
<pre><code>xcodebuild archive -workspace ${project_name}.xcworkspace \
               -scheme ${scheme_name} \
               -configuration ${build_configuration} \
               -archivePath ${export_archive_path}
</code></pre><ul>
<li><p>参数一：项目类型，，如果是混合项目 workspace 就用 <code>-workspace</code>，如果是 project 就用 <code>-project</code></p>
</li>
<li><p><code>-scheme</code>：项目名，上面<code>xcodebuild -list</code>中的 <code>Schemes</code></p>
</li>
<li><p><code>-configuration</code>：编译类型，在<code>configuration</code>选择, <code>Debug</code> 或者 <code>Release</code></p>
</li>
<li><p><code>-archivePath</code>：生成 archive 包的路径，需要精确到 <code>xx/xx.archive</code></p>
</li>
</ul>
<p>首先需要创建一个<code>AdHocExportOptions.plist</code>文件</p>
<h3 id="导出ipa包"><a href="#导出ipa包" class="headerlink" title="导出ipa包"></a>导出ipa包</h3><p>导出<code>.ipa</code>包经常会出现错误，<del>在ruby2.4.0版本中会报错，所以请使用其他版本的ruby</del>,最初的原因是使用了 ruby2.4.0 进行编译时出现的错误。</p>
<p>解决方法是低版本的 ruby 进行编译，如使用系统版本：<code>rvm use system</code>。后面升级macOS系统（10.12.5）后发现 ruby2.4.0 能成功 导出ipa包了。</p>
<p>导出ipa包使用命令：<code>xcodebuild  -exportArchive</code></p>
<pre><code>xcodebuild  -exportArchive \
            -archivePath ${export_archive_path} \
            -exportPath ${export_ipa_path} \
            -exportOptionsPlist ${ExportOptionsPlistPath}
</code></pre><ul>
<li><code>archivePath</code>：上面生成 archive 的路径</li>
<li><code>-exportPath</code>：导出 ipa包 的路径</li>
<li><code>exportOptionsPlist</code>：导出 ipa包 类型，需要指定格式的<code>plist</code>文件，分别是<code>AppStroe</code>、<code>AdHoc</code>、<code>Enterprise</code>,如下图</li>
</ul>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gy1ff1bcz534ij30g609uq48.jpg" alt=""></p>
<p>选择这三个类别需要分别创建三个<code>plist</code>文件：</p>
<ul>
<li><p><code>AdHocExportOptionsPlist.plist</code></p>
<p>  <img src="https://ww3.sinaimg.cn/large/006tNc79gy1ff1bhmwvxfj30ax01pdfu.jpg" alt=""></p>
</li>
<li><p><code>AppStoreExportOptionsPlist.plist</code></p>
<p>  <img src="https://ww3.sinaimg.cn/large/006tNc79gy1ff1bijdlsgj30bh01st8q.jpg" alt=""></p>
</li>
<li><p><code>EnterpriseExportOptionsPlist.plist</code></p>
<p>  <img src="https://ww4.sinaimg.cn/large/006tNc79gy1ff1bishpk8j30be01sglm.jpg" alt=""></p>
</li>
</ul>
<h3 id="上传到-Fir"><a href="#上传到-Fir" class="headerlink" title="上传到 Fir"></a>上传到 Fir</h3><p>将项目上传到 <a href="https://fir.im" target="_blank" rel="external">Fir</a></p>
<p>下载 <a href="https://github.com/FIRHQ/fir-cli/blob/master/doc/install.md" target="_blank" rel="external">fir 命令行工具</a> </p>
<pre><code>gem install fir-cli
</code></pre><p>获取 fir 的 API Token（右上角）</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gy1ff28ccsqhyj304t07bwei.jpg" alt=""></p>
<p>上传</p>
<pre><code>fir publish &quot;ipa_Path&quot; -T &quot;firApiToken&quot;
</code></pre><h2 id="自动打包脚本"><a href="#自动打包脚本" class="headerlink" title="自动打包脚本"></a>自动打包脚本</h2><p><del>再次提醒，请不要使用 ruby 2.4.0 运行该脚本！</del>，若在 ruby 2.4.0 下编译失败，请切换低版本的ruby。</p>
<p>切换完毕记得重新安装 fir 命令行工具。</p>
<p>脚本我fork了 <a href="https://github.com/jkpang/PPAutoPackageScript" target="_blank" rel="external">jkpang</a> 的脚本进行修改，添加了自动上传到 fir 的功能。</p>
<p>使用方法在Github上有详细介绍。</p>
<p>GitHub：<a href="https://github.com/qiubaiying/iOSAutoArchiveScript" target="_blank" rel="external">https://github.com/qiubaiying/iOSAutoArchiveScript</a></p>
<h3 id="利用-自定义终端指令-简化打包过程"><a href="#利用-自定义终端指令-简化打包过程" class="headerlink" title="利用 自定义终端指令 简化打包过程"></a>利用 自定义终端指令 简化打包过程</h3><p>以zsh为例:</p>
<pre><code>open ~/.zshrc
</code></pre><p>添加自定义命令 cd + sh</p>
<pre><code>alias mybuild=&apos;cd 项目地址/iOSAutoArchiveScript/ &amp;&amp;  sh 项目地址/iOSAutoArchiveScript/iOSAutoArchiveScript.sh&apos;
</code></pre><p>这样打开终端输入<code>mybuild</code>，就可以轻松实现一键打包上传了</p>
<blockquote>
<p>本文首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="external">BY Blog</a>, 作者 <a href="http://github.com/qiubaiying" target="_blank" rel="external">@柏荧(BY)</a> ,转载请保留原文链接.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/13/2017-04-13-CocoaPods-安装和使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JimmyZhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy'Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/13/2017-04-13-CocoaPods-安装和使用/" itemprop="url">CocoaPods 安装和使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T00:00:00+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近换了新机器，重新搭建了开发环境，其中当然包括 <strong>CocoaPods</strong>。</p>
<p>装完顺便更新下 <strong>CocoaPods</strong> 安装文档。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>CocoaPods</strong> 是用 ruby 实现的，要想使用它首先需要有 ruby 的环境。</p>
<h4 id="升级ruby"><a href="#升级ruby" class="headerlink" title="升级ruby"></a>升级ruby</h4><pre><code>查看ruby版本 
$ ruby -v

ruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin16]
</code></pre><p>CocoaPods需要<strong>2.2.2</strong>版本及以上的，我们先升级ruby。</p>
<p>使用 <strong>rvm</strong> 安装 ruby</p>
<pre><code>curl -L get.rvm.io | bash -s stable 
source ~/.bashrc
source ~/.bash_profile
</code></pre><p>切换 ruby 源</p>
<p>ruby 下载源使用亚马逊的云服务被墙了，切换国内的 <strong>ruby-china源</strong> （<a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a>已经停止维护，详情<a href="https://ruby.taobao.org/" target="_blank" rel="external">查看公告</a>）：</p>
<pre><code>$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/
$ gem sources -l
*** CURRENT SOURCES ***

https://gems.ruby-china.org
</code></pre><p>安装并切换 ruby</p>
<blockquote>
<p>这里不建议安装最新的 2.4.0 版本，因为次版本的 ruby，在xcodebuild 自动打包时，会出现问题！ 所以退一步，安装 2.3.3版本~</p>
</blockquote>
<pre><code>rvm install 2.3.3 --disable-binary
rvm use 2.3.3 --default
</code></pre><p>到此ruby升级完毕.</p>
<p>有关RVM的使用可以看这篇 <a href="http://qiubaiying.github.io/2017/04/28/RVM-使用指南/" target="_blank" rel="external">RVM 使用指南</a></p>
<h4 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h4><ol>
<li><p>安装</p>
<pre><code>sudo gem install -n /usr/local/bin cocoapods
</code></pre></li>
<li><p>升级版本库</p>
<pre><code>pod setup
</code></pre><p> 这里需要下载版本库（非常庞大），需要等很久</p>
<pre><code>Receiving objects:  72% (865815/1197150), 150.07 MiB | 190.00 KiB/s
</code></pre><p> 或者直接从其他装有cocoapod的电脑中拷贝<code>~/.cocoapods</code>到你的用户目录，然后再 <code>pod setup</code>会节省不少时间</p>
</li>
</ol>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h4 id="创建-podfile-文件"><a href="#创建-podfile-文件" class="headerlink" title="创建 podfile 文件"></a>创建 <code>podfile</code> 文件</h4><p>绝大多数人创建<code>podfile</code>都是用 <code>vim Podfile</code> 命令</p>
<p>其实pod 已经提供了创建 <code>podfile</code> 文件的命令，在工程目录下</p>
<pre><code>pod init
</code></pre><p>将会自动生成 <code>podfile</code> 文件，并且为你写好了格式，稍做修改就能使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># Uncomment the next line to define a global platform for your project</div><div class="line"># platform :ios, &apos;9.0&apos;</div><div class="line"></div><div class="line">target &apos;projectName&apos; do</div><div class="line">  # Comment the next line if you&apos;re not using Swift and don&apos;t want to use dynamic frameworks</div><div class="line">  use_frameworks!</div><div class="line"></div><div class="line">  # Pods for projectName</div><div class="line"></div><div class="line">  target &apos;projectNameTests&apos; do</div><div class="line">    inherit! :search_paths</div><div class="line">    # Pods for testing</div><div class="line">  end</div><div class="line"></div><div class="line">  target &apos;projectNameUITests&apos; do</div><div class="line">    inherit! :search_paths</div><div class="line">    # Pods for testing</div><div class="line">  end</div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure>
<p>其中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">target &apos;projectNameTests&apos; do</div><div class="line">    inherit! :search_paths</div><div class="line">    # Pods for testing</div><div class="line">  end</div><div class="line"></div><div class="line">  target &apos;projectNameUITests&apos; do</div><div class="line">    inherit! :search_paths</div><div class="line">    # Pods for testing</div><div class="line">  end</div></pre></td></tr></table></figure>
<p>是指定在单元测试和UI测试时导入的测试框架，若没有使用测试框架可以删除。</p>
<p>修改iOS版本，添加<code>Alamofire</code>库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Uncomment the next line to define a global platform for your project</div><div class="line"># platform :ios, &apos;8.0&apos;</div><div class="line"></div><div class="line">target &apos;projectName&apos; do</div><div class="line">  # Comment the next line if you&apos;re not using Swift and don&apos;t want to use dynamic frameworks</div><div class="line">  use_frameworks!</div><div class="line"></div><div class="line">  # Pods for projectName</div><div class="line">  </div><div class="line">  pod &apos;Alamofire&apos;, &apos;~&gt; 4.4&apos;</div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure>
<h4 id="加载代码库"><a href="#加载代码库" class="headerlink" title="加载代码库"></a>加载代码库</h4><p>使用下面的命令，直接在本地版本库中查找对应的代码库信息，不升级版本库，节省时间</p>
<pre><code>pod install --verbose --no-repo-update
</code></pre><p>若找不到库，再使用下面的命令</p>
<pre><code>pod install
</code></pre><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>对版本号的操作除了指定与不指定，你还可以做其他操作：</p>
<ul>
<li><code>\&gt;0.1</code>  高于0.1的任何版本</li>
<li><code>\&gt;=0.1</code>  版本0.1和任何更高版本</li>
<li><code>&lt;0.1</code>  低于0.1的任何版本</li>
<li><code>&lt;=0.1</code>  版本0.1和任何较低的版本</li>
<li><code>〜&gt;0.1.2</code>  版本 0.1.2的版本到0.2 ，不包括0.2。<br>这个基于你指定的版本号的最后一个部分。这个例子等效于&gt;= 0.1.2并且 &lt;0.2.0，并且始终是你指定范围内的最新版本</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于<strong>CocoaPods</strong>的安装和使用就这样简单的介绍完了，至于更多使用的方法（平时也用不到~）你可以用下面命令查看</p>
<pre><code>$ pod
</code></pre><p>若对 CocoaPods 的<strong>个人仓库</strong>感兴趣，也可以看看我的这两篇博客</p>
<ul>
<li><a href="http://qiubaiying.top/2017/03/08/CocoaPods%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA/" target="_blank" rel="external">CocoaPods公有仓库的创建</a></li>
<li><p><a href="http://qiubaiying.top/2017/03/10/CocoaPods%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA/" target="_blank" rel="external">CocoaPods私有仓库的创建</a></p>
<blockquote>
<p>本文首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="external">BY Blog</a>, 作者 <a href="http://github.com/qiubaiying" target="_blank" rel="external">@柏荧(BY)</a> ,转载请保留原文链接.</p>
</blockquote>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/07/2017-04-07-强化-Swift-中的-print/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JimmyZhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy'Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/07/2017-04-07-强化-Swift-中的-print/" itemprop="url">强化 swift 中的 print</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-07T00:00:00+08:00">
                2017-04-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 Swift 中，最简单的输出方法就是使用 <code>print()</code>，在我们关心的地方输出字符串和值。</p>
<p>当程序变得非常复杂的时候，我们可能会输出很多内容，而想在其中寻找到我们希望的输出其实并不容易。我们往往需要更好更精确的输出，这包括输出这个 log 的文件，调用的行号以及所处的方法名字等等。</p>
<p>在 Swift 中，编译器为我们准备了几个很有用的编译符号，它们分别是：</p>
<table><thead><br><tr><br><th>符号</th><br><th>类型</th><br><th>描述</th><br></tr><br></thead><tbody><br><tr><br><td>#file</td><br><td>String</td><br><td>包含这个符号的文件的路径</td><br></tr><br><tr><br><td>#line</td><br><td>Int</td><br><td>符号出现处的行号</td><br></tr><br><tr><br><td>#column</td><br><td>Int</td><br><td>符号出现处的列</td><br></tr><br><tr><br><td>#function</td><br><td>String</td><br><td>包含这个符号的方法名字</td><br></tr><br></tbody></table>


<p>有了上面的这些编译符号，我们就可以自定义一个输出函数：<code>printm</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">printm</span><span class="params">(items: Any..., filename: String = #file, function: String = #function, line: Int = #line)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"[<span class="subst">\((filename <span class="keyword">as</span> NSString)</span>.lastPathComponent) <span class="subst">\(line)</span> <span class="subst">\(function)</span>]\n"</span>,items)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为输出是一个很消耗性能的操作，所以在releass环境下需要将输出函数去掉，将上面的函数换成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">printm</span><span class="params">(items: Any..., filename: String = #file, function: String = #function, line: Int = #line)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"[<span class="subst">\((filename <span class="keyword">as</span> NSString)</span>.lastPathComponent) <span class="subst">\(line)</span> <span class="subst">\(function)</span>]\n"</span>,items)</div><div class="line">&#125;</div><div class="line"></div><div class="line">#<span class="keyword">else</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">printm</span><span class="params">(items: Any..., filename: String = #file, function: String = #function, line: Int = #line)</span></span> &#123; &#125;</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h4><ul>
<li><a href="http://swifter.tips/log/" target="_blank" rel="external">《LOG 输出》</a> - 王巍 (@ONEVCAT)</li>
</ul>
<blockquote>
<p>本文首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="external">BY Blog</a>, 作者 <a href="http://github.com/qiubaiying" target="_blank" rel="external">@柏荧(BY)</a> ,转载请保留原文链接.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/30/2017-03-30-Swift 3.1-的新变化「译」/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JimmyZhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy'Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/30/2017-03-30-Swift 3.1-的新变化「译」/" itemprop="url">Swift 3.1 的新变化「译」</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-30T00:00:00+08:00">
                2017-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://koenig-media.raywenderlich.com/uploads/2017/03/WhatsNewSwift3.1-feature-1-250x250.png" alt=""></p>
<p>Xcode 8.3 和 Swift 3.1 现在已经发布了(3/28)！</p>
<p>可以通过 <a href="https://itunes.apple.com/us/app/xcode/id497799835?ls=1&amp;mt=12#" target="_blank" rel="external">AppStore</a> 或 <a href="https://developer.apple.com/download/more/" target="_blank" rel="external">Apple Developer</a> 进行下载</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwgy1fe2it3xwt6j30s50g3mya.jpg" alt=""></p>
<p>Xcode 8.3 优化了 Objective-C 与 Swift 混编项目的编译速度.</p>
<p>Swift 3.1 版本包含一些期待已久的 <a href="https://github.com/apple/swift-package-manager" target="_blank" rel="external">Swift package manager</a> 功能和语法本身的改进。</p>
<p>如果您没有密切关注 <a href="https://github.com/apple/swift-evolution" target="_blank" rel="external">Swift Evolution</a> 进程，请继续阅读 - 本文非常适合您！</p>
<p>在本文中，我将强调Swift 3.1中最重要的变化，这将对您的代码产生重大影响。我们来吧！😃</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>Swift 3.1与Swift 3.0源代码兼容，因此如果您已经使用Xcode 中的 <code>Edit \ Convert \ To Current Swift Syntax ...</code> 将项目迁移到Swift 3.0，新功能将不会破坏您的代码。不过，苹果已经在Xcode 8.3中支持Swift 2.3。所以如果你还没有从Swift 2.3迁移，现在是时候这样做了！</p>
<p>在下面的部分，您会看到链接的标签，如<code>[SE-0001]</code>。这些是 <a href="https://apple.github.io/swift-evolution/" target="_blank" rel="external">Swift Evolution</a> 提案号码。我已经列出了每个提案的链接，以便您可以发现每个特定更改的完整详细信息。我建议您尝试在Playground上验证新的功能，以便更好地了解所有更改的内容。</p>
<blockquote>
<p>Note:如果你想了解 swift 3.0 中的新功能，可以看<a href="https://www.raywenderlich.com/135655/whats-new-swift-3" target="_blank" rel="external">这篇文章</a>。</p>
</blockquote>
<h2 id="语法改进"><a href="#语法改进" class="headerlink" title="语法改进"></a>语法改进</h2><p>首先，我们来看看这个版本中的语法改进，包括关于数值类型的<code>可失败构造器</code>（<code>Failable Initializers</code>），新的序列函数等等。</p>
<h4 id="可失败的数值转换构造器（Failable-Numeric-Conversion-Initializers）"><a href="#可失败的数值转换构造器（Failable-Numeric-Conversion-Initializers）" class="headerlink" title="可失败的数值转换构造器（Failable Numeric Conversion Initializers）"></a>可失败的数值转换构造器（Failable Numeric Conversion Initializers）</h4><p>Swift 3.1 为所有数值类型 <code>(Int, Int8, Int16, Int32, Int64, UInt, UInt8, UInt16, UInt32, UInt64, Float, Float80, Double)</code> 添加了<a href="https://www.swiftmi.com/topic/121.html" target="_blank" rel="external">可失败构造器</a>。</p>
<p>这个功能非常有用，例如，以安全、可恢复的方式处理外源松散类型数据的转换，下面来看 Student 的 JSON 数组的处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">  <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">  <span class="keyword">let</span> grade: <span class="type">Int</span></div><div class="line"> </div><div class="line">  <span class="keyword">init</span>?(json: [<span class="type">String</span>: <span class="type">Any</span>]) &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name = json[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</div><div class="line">          <span class="keyword">let</span> gradeString = json[<span class="string">"grade"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</div><div class="line">          <span class="keyword">let</span> gradeDouble = <span class="type">Double</span>(gradeString),</div><div class="line">          <span class="keyword">let</span> grade = <span class="type">Int</span>(exactly: gradeDouble)  <span class="comment">// &lt;-- 3.1 的改动在这</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">self</span>.name = name</div><div class="line">    <span class="keyword">self</span>.grade = grade</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeStudents</span><span class="params">(with data: Data)</span></span> -&gt; [<span class="type">Student</span>] &#123;</div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> json = <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .allowFragments),</div><div class="line">        <span class="keyword">let</span> jsonArray = json <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">Any</span>]] <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> []</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> jsonArray.flatMap(<span class="type">Student</span>.<span class="keyword">init</span>)</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">let</span> rawStudents = <span class="string">"[&#123;\"name\":\"Ray\", \"grade\":\"5.0\"&#125;, &#123;\"name\":\"Matt\", \"grade\":\"6\"&#125;,</span></div><div class="line"><span class="string">                    &#123;\"name\":\"Chris\", \"grade\":\"6.33\"&#125;, &#123;\"name\":\"Cosmin\", \"grade\":\"7\"&#125;, </span></div><div class="line"><span class="string">                    &#123;\"name\":\"Steven\", \"grade\":\"7.5\"&#125;]"</span></div><div class="line"><span class="keyword">let</span> data = rawStudents.data(using: .utf8)!</div><div class="line"><span class="keyword">let</span> students = makeStudents(with: data)</div><div class="line"><span class="built_in">dump</span>(students) <span class="comment">// [(name: "Ray", grade: 5), (name: "Matt", grade: 6), (name: "Cosmin", grade: 7)]</span></div></pre></td></tr></table></figure>
<p>在 <code>Student</code> 类中使用了一个可失败构造器将 <code>grade</code> 属性从 <code>Double</code> 转变为 <code>Int</code>，像这样</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> grade = <span class="type">Int</span>(exactly: gradeDouble)</div></pre></td></tr></table></figure>
<p>如果<code>gradeDouble</code>不是整数，例如6.33，它将失败。如果它可以用一个正确的表示Int，例如6.0，它将成功。</p>
<blockquote>
<p>Note：虽然<code>throwing initializers</code> 可以用来替代 <code>failable initializers</code>。但是使用 <code>failable initializers</code> 会更好，更符合人的思维。</p>
</blockquote>
<h5 id="新的序列函数（Sequence-Functions）"><a href="#新的序列函数（Sequence-Functions）" class="headerlink" title="新的序列函数（Sequence Functions）"></a>新的序列函数（Sequence Functions）</h5><p>swift3.1添加了两个新的标准库函数在 <code>Sequence</code> 协议中：<code>prefix(while:)``和prefix(while:)</code><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0045-scan-takewhile-dropwhile.md" target="_blank" rel="external">[SE-0045]</a>。</p>
<p>构造一个<a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="external">斐波纳契</a>无限序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fibonacci = sequence(state: (<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">  (state: <span class="keyword">inout</span> (<span class="type">Int</span>, <span class="type">Int</span>)) -&gt; <span class="type">Int</span>? <span class="keyword">in</span></div><div class="line">  <span class="keyword">defer</span> &#123;state = (state.<span class="number">1</span>, state.<span class="number">0</span> + state.<span class="number">1</span>)&#125;</div><div class="line">  <span class="keyword">return</span> state.<span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Swift 3.0中，您只需指定<code>迭代次数</code>即可遍历fibonacci序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift 3.0</span></div><div class="line"><span class="keyword">for</span> number <span class="keyword">in</span> fibonacci.<span class="keyword">prefix</span>(<span class="number">10</span>) &#123;</div><div class="line">  <span class="built_in">print</span>(number)  <span class="comment">// 0 1 1 2 3 5 8 13 21 34</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在swift 3.1中，您可以使用<code>prefix(while:)</code>和<code>drop(while:)</code>获得符合条件在两个给定值之间的序列中的所有元素，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift 3.1</span></div><div class="line"><span class="keyword">let</span> interval = fibonacci.<span class="keyword">prefix</span>(<span class="keyword">while</span>: &#123;$<span class="number">0</span> &lt; <span class="number">1000</span>&#125;).drop(<span class="keyword">while</span>: &#123;$<span class="number">0</span> &lt; <span class="number">100</span>&#125;)</div><div class="line"><span class="keyword">for</span> element <span class="keyword">in</span> interval &#123;</div><div class="line">  <span class="built_in">print</span>(element) <span class="comment">// 144 233 377 610 987</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>prefix(while:)</code>返回满足某个谓词的最长子序列。它从序列的开头开始，并停在给定闭包返回false的第一个元素上。</p>
<p><code>drop(while:)</code> 相反：它返回从给定关闭返回false的第一个元素开始的子序列，并在序列结尾完成。</p>
<blockquote>
<p>Note:这种情况，可以使用尾随闭包的写法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">let</span> interval = fibonacci.<span class="keyword">prefix</span>&#123;$<span class="number">0</span> &lt; <span class="number">1000</span>&#125;.drop&#123;$<span class="number">0</span> &lt; <span class="number">100</span>&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="Concrete-Constrained-Extensions（姑且翻译为类的约束扩展吧）"><a href="#Concrete-Constrained-Extensions（姑且翻译为类的约束扩展吧）" class="headerlink" title="Concrete Constrained Extensions（姑且翻译为类的约束扩展吧）"></a>Concrete Constrained Extensions（姑且翻译为类的约束扩展吧）</h2><p>Swift 3.1允许您扩展具有类型约束的通用类型。以前，你不能像这样扩展类型，因为约束必须是一个协议。我们来看一个例子。</p>
<p>例如，Ruby on Rails提供了一种<code>isBlank</code>检查用户输入的非常有用的方法。以下是在Swift 3.0中用 <code>String</code> 类型的扩展实现这个<strong>计算型属性</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift 3.0</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> isBlank: <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> trimmingCharacters(<span class="keyword">in</span>: .whitespaces).isEmpty</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">let</span> abc = <span class="string">" "</span></div><div class="line"><span class="keyword">let</span> def = <span class="string">"x"</span></div><div class="line"> </div><div class="line">abc.isBlank <span class="comment">// true</span></div><div class="line">def.isBlank <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>如果你希望<code>isBlank</code>计算型属性为一个可选值所用，在swift 3.0中，你将要这样做</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift 3.0</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">StringProvider</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> string: <span class="type">String</span> &#123;<span class="keyword">get</span>&#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>: <span class="title">StringProvider</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> string: <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> <span class="title">where</span> <span class="title">Wrapped</span>: <span class="title">StringProvider</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> isBlank: <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>?.string.isBlank ?? <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">let</span> foo: <span class="type">String</span>? = <span class="literal">nil</span></div><div class="line"><span class="keyword">let</span> bar: <span class="type">String</span>? = <span class="string">"  "</span></div><div class="line"><span class="keyword">let</span> baz: <span class="type">String</span>? = <span class="string">"x"</span></div><div class="line"> </div><div class="line">foo.isBlank <span class="comment">// true</span></div><div class="line">bar.isBlank <span class="comment">// true</span></div><div class="line">baz.isBlank <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>这创建了一个采用 <code>String</code> 的 <code>StringProvider</code> 协议而在你使用StringProvider扩展可选的 wrapped 类型时,添加isBlank方法。</p>
<p>Swift 3.1中，用来替代协议方法，扩展具体类型的方法像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift 3.1</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> <span class="title">where</span> <span class="title">Wrapped</span> == <span class="title">String</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> isBlank: <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>?.isBlank ?? <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就用更少的代码实现了和原先相同的功能~</p>
<h2 id="泛型嵌套（Nested-Generics）"><a href="#泛型嵌套（Nested-Generics）" class="headerlink" title="泛型嵌套（Nested Generics）"></a>泛型嵌套（Nested Generics）</h2><p>Swift 3.1允许您将嵌套类型与泛型混合。作为一个练习，考虑这个（不是太疯狂）的例子。每当某个团队领导raywenderlich.com想在博客上发布一篇文章时，他会分配一批专门的开发人员来处理这个问题，以满足网站的高质量标准：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Team</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">TeamType</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> swift</div><div class="line">    <span class="keyword">case</span> iOS</div><div class="line">    <span class="keyword">case</span> macOS</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">BlogPost</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">BlogPostType</span> </span>&#123;</div><div class="line">      <span class="keyword">case</span> tutorial</div><div class="line">      <span class="keyword">case</span> article</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">let</span> title: <span class="type">T</span></div><div class="line">    <span class="keyword">let</span> type: <span class="type">BlogPostType</span></div><div class="line">    <span class="keyword">let</span> category: <span class="type">TeamType</span></div><div class="line">    <span class="keyword">let</span> publishDate: <span class="type">Date</span></div><div class="line"> </div><div class="line">    <span class="keyword">init</span>(title: <span class="type">T</span>, type: <span class="type">BlogPostType</span>, category: <span class="type">TeamType</span>, publishDate: <span class="type">Date</span>) &#123;</div><div class="line">      <span class="keyword">self</span>.title = title</div><div class="line">      <span class="keyword">self</span>.type = type</div><div class="line">      <span class="keyword">self</span>.category = category</div><div class="line">      <span class="keyword">self</span>.publishDate = publishDate</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> type: <span class="type">TeamType</span></div><div class="line">  <span class="keyword">let</span> author: <span class="type">T</span></div><div class="line">  <span class="keyword">let</span> teamLead: <span class="type">T</span></div><div class="line">  <span class="keyword">let</span> blogPost: <span class="type">BlogPost</span>&lt;<span class="type">T</span>&gt;</div><div class="line"> </div><div class="line">  <span class="keyword">init</span>(type: <span class="type">TeamType</span>, author: <span class="type">T</span>, teamLead: <span class="type">T</span>, blogPost: <span class="type">BlogPost</span>&lt;<span class="type">T</span>&gt;) &#123;</div><div class="line">    <span class="keyword">self</span>.type = type</div><div class="line">    <span class="keyword">self</span>.author = author</div><div class="line">    <span class="keyword">self</span>.teamLead = teamLead</div><div class="line">    <span class="keyword">self</span>.blogPost = blogPost</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将<code>BlogPost</code>内部类嵌套在其对应的<code>Team</code>外部类中，并使两个类都通用。这是团队如何寻找我在网站上发布的教程和文章：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="type">Team</span>(type: .swift, author: <span class="string">"Cosmin Pupăză"</span>, teamLead: <span class="string">"Ray Fix"</span>, </div><div class="line">     blogPost: <span class="type">Team</span>.<span class="type">BlogPost</span>(title: <span class="string">"Pattern Matching"</span>, type: .tutorial, </div><div class="line">     category: .swift, publishDate: <span class="type">Date</span>()))</div><div class="line"> </div><div class="line"><span class="type">Team</span>(type: .swift, author: <span class="string">"Cosmin Pupăză"</span>, teamLead: <span class="string">"Ray Fix"</span>, </div><div class="line">     blogPost: <span class="type">Team</span>.<span class="type">BlogPost</span>(title: <span class="string">"What's New in Swift 3.1?"</span>, type: .article, </div><div class="line">     category: .swift, publishDate: <span class="type">Date</span>()))</div></pre></td></tr></table></figure>
<p>但实际上，在这种情况下，您可以简化该代码。如果嵌套的内部类型使用通用外部类型，那么它默认继承父类的类型。因此，您不需要如此声明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Team</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="comment">// original code </span></div><div class="line"> </div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">BlogPost</span> </span>&#123;</div><div class="line">    <span class="comment">// original code</span></div><div class="line">  &#125;  </div><div class="line"> </div><div class="line">  <span class="comment">// original code </span></div><div class="line">  <span class="keyword">let</span> blogPost: <span class="type">BlogPost</span></div><div class="line"> </div><div class="line">  <span class="keyword">init</span>(type: <span class="type">TeamType</span>, author: <span class="type">T</span>, teamLead: <span class="type">T</span>, blogPost: <span class="type">BlogPost</span>) &#123;</div><div class="line">    <span class="comment">// original code   </span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Note：如果您想了解更多关于Swift中的<strong>泛型</strong>，请阅读我们最近更新的<a href="https://www.raywenderlich.com/154371/swift-generics-tutorial-getting-started" target="_blank" rel="external">Swift泛型入门的教程</a>。</p>
</blockquote>
<h2 id="Swift版本的可用性"><a href="#Swift版本的可用性" class="headerlink" title="Swift版本的可用性"></a>Swift版本的可用性</h2><p>您可以使用<strong>#if swift(&gt;= N)</strong> <code>静态构造</code>来检查特定的Swift版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift 3.0</span></div><div class="line">#<span class="keyword">if</span> swift(&gt;=<span class="number">3.1</span>)</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">intVersion</span><span class="params">(number: Double)</span></span> -&gt; <span class="type">Int</span>? &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Int</span>(exactly: number)</div><div class="line">  &#125;</div><div class="line">#elseif swift(&gt;=<span class="number">3.0</span>)</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">intVersion</span><span class="params">(number: Double)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Int</span>(number)</div><div class="line">  &#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>然而，当使用Swift标准库时，这种方法有一个主要缺点。它需要为每个受支持的旧语言版本编译标准库。这是因为当您以向后兼容模式运行Swift编译器时，例如您要使用Swift 3.0行为，则需要使用针对该特定兼容性版本编译的标准库版本。如果您使用版本3.1模式编译的，那么您根本就没有正确的代码</p>
<p>因此，@available除了现有平台版本 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0141-available-by-swift-version.md" target="_blank" rel="external">[SE-0141]</a> 之外，Swift 3.1扩展了该属性以支持指定Swift版本号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift 3.1</span></div><div class="line"> </div><div class="line"><span class="meta">@available</span>(swift <span class="number">3.1</span>)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">intVersion</span><span class="params">(number: Double)</span></span> -&gt; <span class="type">Int</span>? &#123;</div><div class="line">  <span class="keyword">return</span> <span class="type">Int</span>(exactly: number)</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="meta">@available</span>(swift, introduced: <span class="number">3.0</span>, obsoleted: <span class="number">3.1</span>)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">intVersion</span><span class="params">(number: Double)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="type">Int</span>(number)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个新功能提供了与<code>intVersionSwift</code>版本有关的方法相同的行为。但是，它只允许像标准库这样的库被编译一次。编译器然后简单地选择可用于所选择的给定兼容性版本的功能。</p>
<blockquote>
<p>Note：注意：如果您想了解更多关于Swift 的<code>可用性属性（ availability attributes）</code>，请参阅我们关于<a href="https://www.raywenderlich.com/139077/availability-attributes-swift" target="_blank" rel="external">Swift中可用性属性的教程</a>。</p>
</blockquote>
<h2 id="逃逸闭包（Escaping-Closures）"><a href="#逃逸闭包（Escaping-Closures）" class="headerlink" title="逃逸闭包（Escaping Closures）"></a>逃逸闭包（Escaping Closures）</h2><p>在Swift 3.0 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0103-make-noescape-default.md" target="_blank" rel="external">[ SE-0103 ]</a> 中函数中的闭包的参数是默认是不逃逸的（non-escaping）。在Swift 3.1中，您可以使用新的函数<code>withoutActuallyEscaping()</code>将非逃逸闭包转换为临时逃逸。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(<span class="number">_</span> f: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>, simultaneouslyWith g: () -&gt; <span class="type">Void</span>,</div><div class="line">             on queue: <span class="type">DispatchQueue</span>) &#123;</div><div class="line">  withoutActuallyEscaping(f) &#123; escapableF <span class="keyword">in</span>     <span class="comment">// 1</span></div><div class="line">    withoutActuallyEscaping(g) &#123; escapableG <span class="keyword">in</span></div><div class="line">      queue.async(execute: escapableF)           <span class="comment">// 2</span></div><div class="line">      queue.async(execute: escapableG)     </div><div class="line"> </div><div class="line">      queue.sync(flags: .barrier) &#123;&#125;             <span class="comment">// 3</span></div><div class="line">    &#125;                                            <span class="comment">// 4</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此函数同时加载两个闭包，然后在两个完成之后返回。</p>
<ol>
<li><code>f</code> 与 <code>g</code> 进入函数后由非逃逸状态，分别转换为逃逸闭包:<code>escapableF</code>和<code>escapableG</code>。</li>
<li>async(execute:) 的调用需要逃逸闭包，我们在上面已经进行了转换。</li>
<li>通过运行<code>sync(flags: .barrier)</code>，您确保<code>async(execute:)</code>方法完全完成，稍后将不会调用闭包。</li>
<li>在范围内使用 <code>escapableF</code> and <code>escapableG</code>.</li>
</ol>
<p>如果你存储临时逃离闭包(即真正逃脱)这将是一个Bug。未来版本的标准库可以检测这个陷阱,如果你试图调用它们。</p>
<h2 id="Swift-Package-Manager-更新"><a href="#Swift-Package-Manager-更新" class="headerlink" title="Swift Package Manager 更新"></a>Swift Package Manager 更新</h2><p>啊，期待已久的 <strong>Swift Package Manage</strong> 的更新了！</p>
<h4 id="可编辑软件包（Editable-Packages）"><a href="#可编辑软件包（Editable-Packages）" class="headerlink" title="可编辑软件包（Editable Packages）"></a>可编辑软件包（Editable Packages）</h4><p>Swift 3.1将<code>可编辑软件包(editable packages)</code>的概念添加到Swift软件包管理器 <a href="https://github.com/apple/swift-package-manager/blob/master/Documentation/Usage.md#editable-packages" target="_blank" rel="external">[ SE-0082 ]</a>。</p>
<p>该<code>swift package edit</code>命令使用现有的<code>Packages</code>并将其转换为<code>editable Packages</code>。使用<code>--end-edit</code>命令将 <code>package manager</code> 还原回 <strong>规范解析的软件包（canonical resolved packag）</strong>。</p>
<h4 id="版本固定（Version-Pinning）"><a href="#版本固定（Version-Pinning）" class="headerlink" title="版本固定（Version Pinning）"></a>版本固定（Version Pinning）</h4><p>Swift 3.1 添加了版本固定的概念[ SE-0145 ]。该 <code>pin</code> 命令 固定一个或所有依赖关系如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ swift package pin --all      <span class="comment">// 固定所有的依赖</span></div><div class="line">$ swift package pin <span class="type">Foo</span>        <span class="comment">// 固定 Foo 在当前的闭包</span></div><div class="line">$ swift package pin <span class="type">Foo</span> --version <span class="number">1.2</span>.<span class="number">3</span>  <span class="comment">// 固定 Foo 在 1.2.3 版本</span></div></pre></td></tr></table></figure>
<p>使用<code>unpin</code>命令恢复到以前的包版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ swift package unpin —all</div><div class="line">$ swift package unpin <span class="type">Foo</span></div></pre></td></tr></table></figure>
<p>Package manager 将每个依赖库的版本固定信息存储在 <code>Package.pins</code> 文件中。如果该文件不存在，则Package manager 会自动创建。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><code>swift package reset</code> 命令将会把 Package 重置干净。</p>
<p><code>swift test --parallel</code> 命令 执行测试。</p>
<h2 id="其他改动"><a href="#其他改动" class="headerlink" title="其他改动"></a>其他改动</h2><p>在 swift 3.1 中还有一些小改动</p>
<h4 id="多重返回函数"><a href="#多重返回函数" class="headerlink" title="多重返回函数"></a>多重返回函数</h4><p>C函数返回两次，例如<code>vfork</code> 和 <code>vfork</code>已经不用了。他们以有趣的方式改变了程序的控制流程。所以 Swift 社区 已经禁止了该行为，以免导致编译错误。</p>
<h4 id="自动链接失效（Disable-Auto-Linking）"><a href="#自动链接失效（Disable-Auto-Linking）" class="headerlink" title="自动链接失效（Disable Auto-Linking）"></a>自动链接失效（Disable Auto-Linking）</h4><p><a href="https://github.com/apple/swift-package-manager" target="_blank" rel="external">Swift Package Manager</a> 禁用了在C语言 <a href="http://nsomar.com/modular-framework-creating-and-using-them/" target="_blank" rel="external"><strong>模块映射（module maps）</strong></a>中的<strong>自动链接</strong>的功能：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift 3.0</span></div><div class="line">module <span class="type">MyCLib</span> &#123;</div><div class="line">    header “foo.h<span class="string">"</span></div><div class="line"><span class="string">    link “MyCLib"</span></div><div class="line">    export *</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// Swift 3.1</span></div><div class="line">module <span class="type">MyCLib</span> &#123;</div><div class="line">    header “foo.h”</div><div class="line">    export *</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Swift 3.1改善了Swift 3.0的一些功能，为即将到来的Swift 4.0的大改动做准备。这些包括对泛型，正则表达式，更科学的<code>String</code>等方面的作出极大的改进。</p>
<p>如果你想了解更多，请转到 <a href="https://developer.apple.com/reference/swift?changes=latest_minor" target="_blank" rel="external">Swift standard library diffs</a> 或者查看官方的的<a href="https://github.com/apple/swift/blob/master/CHANGELOG.md" target="_blank" rel="external">Swift CHANGELOG</a>，您可以在其中阅读所有更改的信息。或者您可以使用它来了解 <strong>Swift 4.0</strong> 中的内容！</p>
<h2 id="著作权声明"><a href="#著作权声明" class="headerlink" title="著作权声明"></a>著作权声明</h2><p>本文译自 <a href="https://www.raywenderlich.com/156352/whats-new-in-swift-3-1" target="_blank" rel="external">What’s New in Swift 3.1?</a></p>
<p>由<a href="http://github.com/qiubaiying" target="_blank" rel="external">@柏荧(BY)</a>进行翻译,首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="external">BY Blog</a>，转载请保留原文链接.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/23/2017-03-23-AsyncDisplayKit-2.0-教程：入门「译」/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JimmyZhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy'Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/23/2017-03-23-AsyncDisplayKit-2.0-教程：入门「译」/" itemprop="url">AsyncDisplayKit 2.0 教程:入门「译」</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-23T00:00:00+08:00">
                2017-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>AsyncDisplayKit 2.0 Tutorial: Getting Started</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>“艺术是你任何能做到极致的事”</p>
</blockquote>
<p><a href="http://asyncdisplaykit.org/" target="_blank" rel="external"><strong>AsyncDisplayKit</strong></a> 是一个UI框架，最初诞生于 Facebook 的 <strong>Paper</strong> 应用程序。它是为了解决 Paper 团队面临的核心问题之一：如何尽可能缓解主线程的压力？</p>
<p>现在,许多应用程序的用户体验,很大程度上依赖于持续手势和物理动画。至少,你的UI可能是依赖于某种形式的 <code>scrollView</code>。</p>
<p>这些类型的用户界面完全依赖于主线程，并且对主线程阻塞非常敏感。主线程阻塞将导致丢帧，降低用户的体验。</p>
<p>一些主线程开销较大的任务包括：</p>
<ul>
<li><strong>计算尺寸和布局</strong>：比如  <code>-heightForRowAtIndexPath:</code>，或者在UILbel中调用 <code>-sizeThatFits</code> 以及<a href="http://floriankugler.com/2013/04/22/auto-layout-performance-on-ios/" target="_blank" rel="external">指数上升</a>的 <code>AutoLayout‘s</code>布局计算。</li>
<li><strong>图像解码</strong>：想要在一个 image view 中使用 <code>UIImage</code>，首先要进行解码。</li>
<li><strong>绘图</strong>：复杂的文本以及手动绘制渐变和阴影。</li>
<li><strong>对象生命周期</strong>：创建，操纵和销毁系统对象（即创建一个UIView）</li>
</ul>
<p>当正确使用时,AsyncDisplayKit 允许您在默认情况下异步执行所有测量、布局和渲染。无需任何额外的优化，一个应用程序可以减少约一个数量级的主线程开销。</p>
<p>除了这些性能优势，酷炫的 AsyncDisplayKit 还为开发者提供的便利接口，用简洁的代码就能完成复杂的功能。</p>
<p>在这两部分 <strong>AsyncDisplayKit 2.0</strong> 教程中，你将掌握使用ASDK构建一个实用的和动态的应用程序的所有要素。在第一部分中，你将要学习一些在你构建应用程序时可以用到的宏观思想。在<a href="https://www.raywenderlich.com/124696/asyncdisplaykit-2-0-tutorial-automatic-layout" target="_blank" rel="external">第二部分</a>中，你将学习如何构建自己 node 的 subclass，以及如何使用ASDK强大的布局引擎。为了更好的完成本教程，你需要会使用 Xcode 以及 熟悉 Objective-C。</p>
<blockquote>
<p><strong>免责声明</strong>：ASDK不兼容 <a href="http://www.youtube.com/watch?v=RY_X7l1g79Q&amp;feature=youtu.be&amp;t=29m37s" target="_blank" rel="external">Interface Builder和AutoLayout</a>，因此，您将不会在本教程中使用它们，虽然ASDK完全支持Swift(除了ComponentKit)，许多开发者仍在使用<br>Objective-C。免费App排行榜前100大多数都没有使用Swift（至少6个使用ASDK）。出于这些原因，本系列将重点介绍 Objective-C。话虽这么说，我们已经包括了一个Swift版本的实例项目。（嘴上说没有，代码还是很诚实的😂~）</p>
</blockquote>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>首先，<a href="https://koenig-media.raywenderlich.com/uploads/2016/12/AsyncDisplayKit-Starter-4.zip" target="_blank" rel="external">下载初始项目</a>。</p>
<p>该项目使用 <a href="https://cocoapods.org/" target="_blank" rel="external">CocoaPods</a> 来拉入AsyncDisplayKit。所以，在正常的 CocoaPods 体系下，打开 <code>RainforestStarter.xcworkspace</code> 而不是<code>RainforestStarter.xcodeproj</code>。</p>
<blockquote>
<p><strong>注意</strong>：需要网络连接才能完成本教程。</p>
</blockquote>
<p>构建并运行以查看包含 <code>UITableView</code> 动物列表的应用程序。如果你看过了代码，<code>AnimalTableController</code> 你会发现这是一个正常且熟悉的 <code>UITableViewController</code> 类。</p>
<blockquote>
<p><strong>注意</strong>：确保在真机上运行本教程中的代码，而不是在模拟器中运行。</p>
</blockquote>
<p>向上滑动你将看到帧数丢失引起的卡顿。你不需要启动控制台，以便能发现到这个应用程序需要在性能方面上的一些优化。</p>
<p>你可以通过 <strong>AsyncDisplayKit</strong> 的力量来解决这个问题</p>
<h1 id="ASDisplayNode-简介"><a href="#ASDisplayNode-简介" class="headerlink" title="ASDisplayNode 简介"></a>ASDisplayNode 简介</h1><p><code>ASDisplayNode</code> 是ASDK的核心类，它只是一个类似于 MVC 中的 “View” 一样的<code>UIView</code> 或 <code>CALayer</code>。认识一个 node 的最佳方法是参照你已经熟悉的 <code>UIViews</code> 和 <code>CALayers</code> 之间的关系。</p>
<p>记住，iOS应用程序中的所有在屏幕上的显示都通过<code>CALayer</code>对象表示的。<code>UIViews</code> 创建并且拥有一个底层的 <code>CALayer</code>，并为他们添加触摸处理和其他交互功能。<code>UIView</code> 并不是 <code>CALayer</code> 的子类，而是相互环绕，扩展其功能。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/03/view-layer-480x229.png" alt="">    </p>
<p>这种抽象的情况下扩展 <code>ASDisplayNode</code>：您可以将它们视为包装一个 view，就像在 view 上添加一个 layer 一样。</p>
<p>通常由 Node 创建的一个常规的view，其创建和配置都在行队列中执行，并且异步渲染。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/03/node-view-layer-480x161.png" alt=""></p>
<p>幸运的是，用于处理 Node 的 API 对于任何使用过的 <code>UIViews</code> 或者 <code>CALayers</code> 的人来说应该异常的熟悉。所有 View 的属性都可以等效为 Node 类。你可以访问基础的 view 或者 layer 本身，就像是访问 <code>view.layer</code> 一样</p>
<h1 id="节点容器（The-Node-Containers）"><a href="#节点容器（The-Node-Containers）" class="headerlink" title="节点容器（The Node Containers）"></a>节点容器（The Node Containers）</h1><p>虽然 Node 本身提供了巨大的性能改进的可能，但真正的强大的是它们与四个容器类结合使用时产生的黑魔法。</p>
<p>这些类包括：</p>
<ul>
<li><strong>ASViewController</strong>：一个 <code>UIViewController</code> 的子类，允许你提供要管理的 Node。</li>
<li><strong>ASCollectionNode</strong> and <strong>ASTableNode</strong>：Node 等效于 <code>UICollectionView</code> 和 <code>UITableView</code>，其子类实际上保留在底层。</li>
<li><strong>ASPagerNode</strong>:一个<code>ASCollectionNode</code>的子类，提供极好的滑动性能相比与 <code>UIKit</code> 的 <code>UIPageViewController</code> 来说。</li>
</ul>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/03/ragecomic-480x229.png" alt=""></p>
<p>说得好，但真正的黑魔法来自 <code>ASRangeController</code> 这些类用于影响所包含的 Node 的行为。现在，跟着我并把你们的脑袋放空吧~</p>
<h1 id="TableNode"><a href="#TableNode" class="headerlink" title="TableNode"></a>TableNode</h1><p>你要做的第一件事就是将当前 TableView 替换为 TableNode。这个没什么难度。</p>
<h4 id="将-TableView-替换为-TableNode"><a href="#将-TableView-替换为-TableNode" class="headerlink" title="将 TableView 替换为 TableNode"></a>将 TableView 替换为 TableNode</h4><p>首先，进入到 <code>AnimalTableController.m</code> 。在此类中添加下面代码下面代码。</p>
<pre><code>#import &lt;AsyncDisplayKit/AsyncDisplayKit.h&gt;
</code></pre><p>这就导入了 ASDK 框架。</p>
<p>然后，我们继续，替换 <code>tableView</code> 的声明属性 ：</p>
<pre><code>@property  （ strong，nonatomic ） UITableView * tableView;
</code></pre><p>替换为 <code>tableNode</code>：</p>
<pre><code>@property  （ strong，nonatomic ） ASTableNode * tableNode;
</code></pre><p>这将导致这个类中很多地方报错，但不要慌张！</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/03/butBut-1-480x229.png" alt=""></p>
<p>别担心。这些错误和警告将作为你的向导，将代码转换成我们想要的。</p>
<p><code>-viewDidLoad</code> 中的报错是理所当然，因为 <code>tableView</code> 已经被替换掉。我不会让你通过 <code>tableNode</code> 替换 所有的 <code>tableView</code> 实例（我的意思是，查找和替换并非那么难），但是如果你做了，你会看到：</p>
<ol>
<li>你应该为 <code>ASTableNode</code> 分配一个属性。</li>
<li>table Node  没有调用 <code>-registerClass:forCellReuseIdentifier:</code> 方法。</li>
<li>你不能添加一个 node 到 subview</li>
</ol>
<p>此时，你应该将 <code>-viewDidLoad</code> 中的方法替换为：</p>
<pre><code>- (void)viewDidLoad {
  [super viewDidLoad];

  [self.view addSubnode:self.tableNode];
  [self applyStyle];
}
</code></pre><p>这里要注意一个有趣的情况，你调用的是 UIView 的一个 <code>-addSubnode:</code> 方法，该方法是通过 category 添加到 <code>UIView</code> 上的，等效于: </p>
<pre><code>[self.view addSubview:self.tableNode.view];
</code></pre><p>接下来，修改 <code>-viewWillLayoutSubviews</code> 中的代码：</p>
<pre><code>- (void)viewWillLayoutSubviews {
  [super viewWillLayoutSubviews];

  self.tableNode.frame = self.view.bounds;
}
</code></pre><p>这样就替换用 <code>self.tableNode</code> 替换了 <code>self.tableView</code>，并且设置了 table 的 Frame</p>
<p>继续修改 <code>-applyStyle</code> 方法中的代码为：</p>
<pre><code>- (void)applyStyle {
  self.view.backgroundColor = [UIColor blackColor];
  self.tableNode.view.separatorStyle = UITableViewCellSeparatorStyleNone;
}
</code></pre><p>这是唯一设置 table 的 <code>separatorStyle</code> 的一行代码。注意 tableNode 的 view 是如何访问 table 的 <code>separatorStyle</code> 属性的。<code>ASTableNode</code> 不会暴露所有<code>UITableView</code>的的属性，所以你必须通过 tableNode 底层的 <code>UITableView</code> 实例去设置 <code>UITableView</code> 的特殊属性。</p>
<p>然后，在 <code>-initWithAnimals:</code> 方法中添加。</p>
<pre><code>_tableNode = [[ASTableNode alloc] initWithStyle:UITableViewStylePlain];
</code></pre><p>并且在 <strong>return</strong> 之前，调用：</p>
<pre><code>[self wireDelegation];
</code></pre><p>这就会在初始化 <code>AnimalTableController</code> 的时候，创建了一个 tableNode 并且调用 <code>-wireDelegation</code> 方法 设置 tableNode 的 代理。</p>
<h4 id="设置-TableNode-的-DataSource-amp-Delegate"><a href="#设置-TableNode-的-DataSource-amp-Delegate" class="headerlink" title="设置  TableNode 的 DataSource &amp; Delegate"></a>设置  TableNode 的 DataSource &amp; Delegate</h4><p>类似于 <code>UITableView</code>，<code>ASTableNode</code> 也使用 DataSource 和 Delegate 来设置本身。TableNode 的<code>ASTableDataSource</code> 和 <code>ASTableDelegate</code> protocols 非常类似于 <code>UITableViewDataSource</code> 和 <code>UITableViewDelegate</code>。</p>
<p>事实上，虽然他们定义了一些完全相同的方法，如 <code>-tableNode:numberOfRowsInSection:</code>，但两组协议也不完全相同，因为 <code>ASTableNode</code> 行为和<code>UITableView</code>还以所有不同的。</p>
<p>找到 <code>-wireDelegation</code> 方法， 并用 <code>tableNode</code> 替换 <code>tableView</code>：</p>
<pre><code>- (void)wireDelegation {
  self.tableNode.dataSource = self;
  self.tableNode.delegate = self;
}
</code></pre><p>现在， 你会收到警告, <code>AnimalTableController</code> 实际上不符合协议。目前，<code>AnimalTableController</code> 仅遵循 <code>UITableViewDataSource</code> 和 <code>UITableViewDelegate</code>协议。在下面的章节中，我们将遵循这些协议，使我们能够使用 tableNode 的功能。</p>
<h4 id="遵循-ASTableDataSource"><a href="#遵循-ASTableDataSource" class="headerlink" title="遵循 ASTableDataSource"></a>遵循 ASTableDataSource</h4><p>在 <code>AnimalTableController.m</code> 开头的地方找到 <code>AnimalTableController</code> 的 <code>DataSource</code> 扩展声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AnimalTableController</span> (<span class="title">DataSource</span>)&lt;<span class="title">UITableViewDataSource</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>用 <code>ASTableDataSource</code> 替换 <code>UITableViewDataSource</code>为：</p>
<pre><code>@interface AnimalTableController (DataSource)&lt;ASTableDataSource&gt;
@end
</code></pre><p>现在，<code>AnimalTableController</code> 已经遵循了 <code>AnimalTableController</code> 协议。本就该如此了。</p>
<p>导航到 <code>AnimalTableController.m</code> 的底部并找到 <code>DataSource</code> category 的实现。</p>
<p>首先，将 <code>UITableViewDataSource</code> 的 <code>-tableView:numberOfRowsInSection:</code>方法，<br>更改为<code>ASTableDataSource</code> 的版本。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)tableNode:(ASTableNode *)tableNode numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>.animals.count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着，<code>ASTableNodes</code> 的 cells 会以不同于 <code>UITableView</code> 的方式返回。用下面的代码替换 <code>-tableView:cellForRowAtIndexPath:</code> 以适应新的规则。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1</span></div><div class="line">- (ASCellNodeBlock)tableNode:(ASTableView *)tableView nodeBlockForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">  </div><div class="line">  <span class="comment">// 2</span></div><div class="line">  RainforestCardInfo *animal = <span class="keyword">self</span>.animals[indexPath.row];</div><div class="line"> </div><div class="line">  <span class="comment">// 3 return ASCellNodeBlock</span></div><div class="line">  <span class="keyword">return</span> ^&#123;</div><div class="line">    <span class="comment">// 4</span></div><div class="line">    CardNode *cardNode = [[CardNode alloc] initWithAnimal:animal];</div><div class="line"> </div><div class="line">    <span class="comment">//You'll add something extra here later...</span></div><div class="line">    <span class="keyword">return</span> cardNode;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让我们整理一下：</p>
<ol>
<li>ASDK 中的 <code>ASCellNode</code> 等价于 <code>UITableViewCell</code> 或者 <code>UICollectionViewCell</code>。要注意的是这个方法返回的是一个 <code>ASCellNodeBlock</code>，<code>ASTableNode</code> 维持着内部所有的 Cell，每个 indexPath 对应一个 block，并且随时准备进行初始化。</li>
<li>你的首要任务是通过数据模型构建cell。这是非常重要的一步，要注意！你获取数据后在 下面的 block 处理。不要在 block 里引用<code>indexPath</code>,以防止 block 运行前的数据变动。</li>
<li>然后返回一个 block，其返回值必须为 <code>ASCellNode</code>。</li>
<li>没有必要担心Cell的复用以及初始化一个Cell的方法。您可能会注意到您现在返回了<code>CardNode</code>，而不是<code>CardCell</code>。</li>
</ol>
<p>这让我想到一个重要的点。或许你已经了解到，<strong>使用 ASDK 不需要复用 cell</strong>，好吧，我已经说了两遍了，但能记住就好。请随意删除顶部<code>kCellReuseIdentifier</code>的定义吧</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *kCellReuseIdentifier = <span class="string">@"CellReuseIdentifier"</span>;</div></pre></td></tr></table></figure>
<p>你不必再担心 <code>-prepareForReuse</code>了</p>
<h4 id="遵循-ASTableDelegate"><a href="#遵循-ASTableDelegate" class="headerlink" title="遵循 ASTableDelegate"></a>遵循 ASTableDelegate</h4><p>在 <code>AnimalTableController.m</code> 顶部，找到以下Delegate类别接口声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AnimalTableController</span> (<span class="title">Delegate</span>)&lt;<span class="title">UITableViewDelegate</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>用 <code>ASTableDelegate</code> 替换 <code>UITableViewDelegate</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AnimalTableController</span> (<span class="title">Delegate</span>)&lt;<span class="title">ASTableDelegate</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>现在 <code>AnimalTableController</code> 已经遵循了 <code>ASTableDelegate</code>，是时候做处理了。在 <code>AnimalTableController.m</code> 底部找到 <code>Delegate</code> 分类的实现。</p>
<p>我们都知道，每个 <code>UITableView</code> 至少都要提供一个 <code>-tableView:heightForRowAtIndexPath:</code> 实现方法，因为每个 cell 的高度都由代理计算和返回。</p>
<p><code>ASTableDelegate</code> 中没有 <code>-tableView:heightForRowAtIndexPath:</code>。再 ASDK 中，所有的 <code>ASCellNode</code> 都负责确定自己的大小。你可以选择为单元格定义最小和最大尺寸，而不是提供静态高度。这种情况下，你希望每个cell的高度至少为屏幕的 2／3。</p>
<p>现在不用担心太多，这个会在第二部分中介绍。</p>
<p>现在只需要替换 <code>-tableView:heightForRowAtIndexPath:</code>为:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (ASSizeRange)tableView:(ASTableView *)tableNode </div><div class="line">  constrainedSizeForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">  <span class="built_in">CGFloat</span> width = [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width;</div><div class="line">  <span class="built_in">CGSize</span> min = <span class="built_in">CGSizeMake</span>(width, ([<span class="built_in">UIScreen</span> mainScreen].bounds.size.height/<span class="number">3</span>) * <span class="number">2</span>);</div><div class="line">  <span class="built_in">CGSize</span> max = <span class="built_in">CGSizeMake</span>(width, INFINITY);</div><div class="line">  <span class="keyword">return</span> ASSizeRangeMake(min, max);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过我们的辛勤劳动，重新编译、运行项目，看看发生了什么。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/InfiniteScrollingGif.gif" alt=""></p>
<p>真是一个流畅的 <code>tableView</code>！一旦你开始做了，那就让我们做的更好吧！</p>
<h2 id="无限滚动"><a href="#无限滚动" class="headerlink" title="无限滚动"></a>无限滚动</h2><p>在大多数应用中，服务器的数据点的个数往往会多于当前 tableView 中显示的单元格数量。这意味着，你必须通过某些手段做无缝处理，以便用户刷完当前数据列表时从服务端加载新的数据。</p>
<p>很多时候，这是通过手动观察滚动视图方法中的内容偏移来处理 <code>scrollViewDidScroll:</code>, 使用 ASDK， 有一种更具说明性的处理方式。相反的，你可以预先确定好你需要加载的页数。</p>
<p>你要做的第一件事是取消已经存在的方法的注释。在 <code>AnimalTableController.m</code> 的结尾，取消 <code>Helpers</code> 分类中的两个方法。你可以认为 <code>-retrieveNextPageWithCompletion:</code> 是你的网络调用，而 <code>-insertNewRowsInTableNode:</code> 是个非常典型的再表中添加新的元素的方法。</p>
<p>接下来，在 <code>-viewDidLoad</code> 添加：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.tableNode.view.leadingScreensForBatching = <span class="number">1.0</span>;  <span class="comment">// overriding default of 2.0</span></div></pre></td></tr></table></figure>
<p>设置 <code>leadingScreensForBatching</code> 为 <strong>1.0</strong> 意味着当用户滑动一个屏的时候，就会载入新的数据。</p>
<p>继续，在 <code>Delegate</code> 分类中实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)shouldBatchFetchForTableNode:(ASTableNode *)tableNode &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法用于告诉 <code>tableView</code> 是否继续请求新的数据。如果返回 <code>NO</code>，则在到达 API 数据末尾时，不会再不会发出任何请求。</p>
<p>因为你希望无限滚动，那就返回 <code>YES</code>，以确保总是请求新的数据。</p>
<p>接下来，还要添加：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableNode:(ASTableNode *)tableNode willBeginBatchFetchWithContext:(ASBatchContext *)context &#123;</div><div class="line">  <span class="comment">//1</span></div><div class="line">  [<span class="keyword">self</span> retrieveNextPageWithCompletion:^(<span class="built_in">NSArray</span> *animals) &#123;</div><div class="line">    <span class="comment">//2</span></div><div class="line">    [<span class="keyword">self</span> insertNewRowsInTableNode:animals];</div><div class="line">    <span class="comment">//3</span></div><div class="line">    [context completeBatchFetching:<span class="literal">YES</span>];</div><div class="line">  &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法在用户滑动到 table 的末端并，且 <code>-shouldBatchFetchForTableNode:</code> 方法返回 <code>YES</code> 时被调用。</p>
<p>让我们回顾下上面的章节：</p>
<ol>
<li>首先，你要请求新的 animals 数据来展示。通常是通过 API 来获取的一组array。</li>
<li>完成后，用新下载的数据更新 tableView</li>
<li>最后，确保 <code>-completeBatchFetching:</code>返回的是<code>YES</code>，即大功告成。在完成操作之前，不会进行新的数据请求。</li>
</ol>
<p>Build and Run，并且不停的滚呀滚。你将会看到不停的看到一只鸟，他们是无限的。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/InfiniteScrollingGif.gif" alt=""></p>
<h2 id="智能预加载"><a href="#智能预加载" class="headerlink" title="智能预加载"></a>智能预加载</h2><p>你在工作中是否曾经遇到需要预先加载内容到 scrollView 或者 pageView 控制器中？也许你正在处理一个充满屏幕 image ，并且总是希望在接下来的几张图片加载时处于等待状态，所以用户很少看到占位符。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/03/iThinkIveGotThis-480x229.png" alt=""></p>
<p>当你再这样的体系下工作时，你很快就会意识到有很多问题要考虑。</p>
<ul>
<li>你占用了多少内存</li>
<li>你应该提前多久加载内容</li>
<li>你决定什么时候忽略用户的交互反映</li>
</ul>
<p>并且当你考虑到多个维度的内容时，将些问题将会变得更加复杂。假设你有一个<code>pageViewController</code>，里面每个 <code>viewController</code> 都带有一个 <code>collectionView</code>。现在，你就需要考虑如何在两个方向上动态加载内容。同时，还要对每个设备进行优化。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/12/officespaceboss.png" alt=""></p>
<p>还记得告诉你 <code>ASRangeController</code> 是不重要的吗？现在，这将是我们的重点。</p>
<p>在每个容器类中，所有包含的 node 都有一个接口状态的概念。在任何给定的时间，一个 node 可以是下面的任意组合：</p>
<ul>
<li><strong>Preload Range（预载范围）</strong>：通常最远的范围从可见区域。这是当cell的每个 subNode （例如ASNetworkImageNode） 的内容从外源加载，例如API和本地缓存。这与批量获取时，使用用模型对象代表cell本身形成对比。</li>
<li><strong>Display Range（显示范围）</strong>：在这里进行显示任务，例如文本绘制和进行图像解码。</li>
<li><strong>Visible Range（可见范围）</strong>：此时，node 至少有一个像素在屏幕上。</li>
</ul>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/12/preloadingRanges-small.png" alt=""></p>
<p>这些范围也适用于 <strong>screenfuls</strong> 的度量，并且可以使用 <code>ASRangeTuningParameters</code> 属性轻松调整。</p>
<p>例如：你正在使用一个 <code>ASNetworkImageNode</code>在 gallery 的每个页面中展示图像，当每个cell进入 <strong>Preload Range</strong> 时，会发送网络请求，并且在进入 <strong>Display Range</strong> 时进行图像解码。</p>
<p>通常来说，你不必对这些 <strong>Ranges</strong> 太较真。利用好已有的组件，如：<code>ASNetworkImageNode</code> 和 <code>ASTextNode</code>，通常来说你将会获得极大的便利。</p>
<blockquote>
<p><strong>注意</strong>: 有件不明显的事，这些 <strong>Ranges</strong> 不是堆栈的。相反，它们会在<br><strong>Visible Range</strong> 上重叠和汇聚。如果将显示和预取都设置为一个屏幕，则它们将完全相同。通常数据需要存在才能显示，所以一般预取范围应该稍大一点。那么在 node 到达该范围时，就可以开始显示。</p>
</blockquote>
<p>通常，该范围的前侧大于后侧。当用户改变其滚动方向时，范围的大小也是相反的，以便于对应用户实际移动的方向。</p>
<h2 id="Node接口的状态回调"><a href="#Node接口的状态回调" class="headerlink" title="Node接口的状态回调"></a>Node接口的状态回调</h2><p>你可能会疑惑：这些 <strong>Ranges</strong> 是如何正确工作的？很高兴你这样问~</p>
<p>系统中的每个 node 都有一个<code>interfaceState</code> 属性，是一个带有字段（(NS_OPTION）<code>ASInterfaceState</code>类型。<code>ASRangeController</code> 负责管理 <code>ASCellNode</code> 在 <code>scrolView</code> 上的移动，每个subNode 都由一个 <code>interfaceState</code> 属性做对应的更新。这意味着即使时 tree 中最深的 nodes 也可以相应 <code>interfaceState</code> 的变化。</p>
<p>幸运的是，我们很少需要直接去操作 node 的 <code>interfaceState</code> 上的 二进制位。更常见的做法时，你只需要对某 node 的特定的状态进行更改。这就是接口的状态回调。</p>
<h4 id="Node-命名"><a href="#Node-命名" class="headerlink" title="Node 命名"></a>Node 命名</h4><p>为了看到一个 node 的各种状态，给它命名时很有必要的。这样，你就可以监测每个 node 的数据加载、内容成、屏幕展示以及所以的事情。</p>
<p>回到代码<code>-tableNode:nodeBlockForRowAtIndexPath:</code>,添加一句注释</p>
<pre><code>//You&apos;ll add something extra here later...
</code></pre><p>在它的下面，给 <code>cardNode</code> 添加一个 <code>debugName</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cardNode.debugName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"cell %zd"</span>, indexPath.row];</div></pre></td></tr></table></figure>
<h4 id="观察-Cells"><a href="#观察-Cells" class="headerlink" title="观察 Cells"></a>观察 Cells</h4><p>进入 <code>CardNode_InterfaceCallbacks.m</code> 中，你可以找到六种追踪 node 在 ranges 中的状态的方法。取消注释，Build and Run。打开你的控制台，然后慢慢滑动 table。对照你的滑动，观察cell在对应的状态变化。</p>
<blockquote>
<p><strong>注意</strong>： 大多数情况下，你只要关心 <code>-didEnterVisibleState</code> 或 <code>-didExitVisibleState</code> 方法对 <code>ASInterfaceState</code> 的改变。或者说，已经为你做好了许多引擎。你可以查看 <code>ASNetworkImageNode</code> 中的代码，看看你集成的通过<code>Preload</code> 和 <code>Display</code> 状态实现的功能。 所有 node 网络图片的请求和解码，以及内存的释放都是自动完成，不费吹灰之力。</p>
</blockquote>
<h2 id="智能预加载（续）"><a href="#智能预加载（续）" class="headerlink" title="智能预加载（续）"></a>智能预加载（续）</h2><p>在 <strong>2.0</strong> 版本中，已经介绍了多个维度上智能与加载的概念。假设你有一个竖直滚动的<code>tableView</code>，在其中某些Cell包含了水平滚动的 <code>collectionView</code>。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/proaldGif%5E2.gif" alt=""></p>
<p>尽管现在的技术能够实现，但你不会希望在到达可见区域之前预先加载全部的 collection。相反的，两个方向上的 scrollView 都由各自的 <code>ASRangeController</code> 单独控制自己的 range 参数。</p>
<h2 id="来到二次元"><a href="#来到二次元" class="headerlink" title="来到二次元"></a>来到二次元</h2><p>现在，你已经有了完整的 <code>AnimalTableController</code>， 你可以把它做为 ASPagerNode 的一个page。</p>
<p>项目已经提前写好了控制器的代码，首先进入 <strong><code>AppDelegate.m</code></strong>。</p>
<p>找到 <code>-installRootViewController</code> 的下面代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AnimalTableController *vc = [[AnimalTableController alloc] </div><div class="line">                              initWithAnimals:[RainforestCardInfo allAnimals]];</div></pre></td></tr></table></figure>
<p>替换为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AnimalPagerController *vc = [[AnimalPagerController alloc] init];</div></pre></td></tr></table></figure>
<p>然后，跳到 <strong><code>AnimalPagerController.m</code></strong> 在 <code>-init</code> 方法中添加创建 <code>pager</code> 方法以及 <code>dataSource</code> 的数据源：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_pagerNode = [[ASPagerNode alloc] init];</div><div class="line">_pagerNode.dataSource = <span class="keyword">self</span>;</div></pre></td></tr></table></figure>
<p>pagerNode 是 <code>ASCollectionNode</code> 的子类，使用方法与 <code>UIPageViewController</code> 一样。API 实际上比 <code>UIPageViewController</code> 要简单的多。</p>
<p>接下来要实现 pager 的 <code>dataSource</code> 方法，在底部找到 <code>ASPagerDataSource</code> 分类.</p>
<p>首先，告诉 pager 有几个页面。实际上当前的 animal 数组中有三组不同动物，我们需要重写 <code>-numberOfPagesInPagerNode:</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)numberOfPagesInPagerNode:(ASPagerNode *)pagerNode &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>.animals.count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，你需要实现 <code>-pagerNode:nodeAtIndex</code> 方法，类似于先前实现的 ASTableNode 的 <code>dataSource</code> 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (ASCellNode *)pagerNode:(ASPagerNode *)pagerNode nodeAtIndex:(<span class="built_in">NSInteger</span>)index &#123;</div><div class="line">    <span class="comment">// 1</span></div><div class="line">    <span class="built_in">NSArray</span> *animals = <span class="keyword">self</span>.animals[index];</div><div class="line">    <span class="comment">// 2</span></div><div class="line">    ASCellNode *node = [[ASCellNode alloc] initWithViewControllerBlock:^<span class="built_in">UIViewController</span> * _Nonnull&#123;</div><div class="line">        <span class="keyword">return</span>  [[AnimalTableController alloc] initWithAnimals:animals];</div><div class="line">    &#125; didLoadBlock:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来总结下这部分：</p>
<ol>
<li>尽管这个版本中没有进行模块化分，但是首先获取数据模型是个好习惯。</li>
<li>这一次，你使用的正是强大的 <code>-initWithViewControllerBlock:</code> 构造器。你所要做的就是返回一个block，这个 block 返回你提前设置好的 tableNodeController，它将自动展示在pager 的 页面中。真是太酷了😏~</li>
</ol>
<p>一旦你添加了这个方法，你将拥有一个完整功能的 Pagar，其中的 cell 是从你原先创建的 <code>tableNodeController</code> 生成的。现在，就可以在用户的垂直和水平滑动下，充分发挥二维预加载的功能！</p>
<p>要查看这个 AsyncDisplayKit 2.0 教程完整的项目，<a href="https://koenig-media.raywenderlich.com/uploads/2016/12/AsyncDisplayKit-Finished-4.zip" target="_blank" rel="external">点击这里进行下载</a>。如果你想查看swift版本，<a href="https://koenig-media.raywenderlich.com/uploads/2016/12/RainForestSwift-1.zip" target="_blank" rel="external">这里也有</a>。</p>
<p>准备好之后，请转到该项目的第2部分，了解 AsyncDisplayKit 2.0 引入的强大的新的布局系统。</p>
<p>如果你想先进行深入了解，你可以阅读 <a href="https://asyncdisplaykit.org/" target="_blank" rel="external">AsyncDisplayKit主页</a> 的文档。Scott Goodson（AsyncDisplayKit的原创作者）也有几个你可能会感兴趣的话题。最近的话题很好的概述了一些框架对处理大图片存在问题的的尝试。</p>
<p>你可能会对 <a href="https://www.youtube.com/watch?v=OiY1cheLpmI" target="_blank" rel="external">Paper的构建</a> 感兴趣。虽然当时并没有开源，并且有许多地方发生了变化，但看到这一切的开始还是挺有意思的。</p>
<p>这里有一个 <a href="https://github.com/facebook/AsyncDisplayKit/issues/1582" target="_blank" rel="external">public Skack channel</a> ,欢迎来提问~</p>
<h1 id="著作权声明"><a href="#著作权声明" class="headerlink" title="著作权声明"></a>著作权声明</h1><p>本文译自 <a href="https://www.raywenderlich.com/124311/asyncdisplaykit-2-0-tutorial-getting-started" target="_blank" rel="external">AsyncDisplayKit 2.0 Tutorial: Getting Started</a> .</p>
<p>由<a href="http://github.com/qiubaiying" target="_blank" rel="external">@柏荧(BY)</a>进行翻译,首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="external">BY Blog</a>，转载请保留原文链接.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/17/2017-03-17-Mac终端(zsh)下用代码编辑器打开文件或目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JimmyZhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy'Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/17/2017-03-17-Mac终端(zsh)下用代码编辑器打开文件或目录/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T00:00:00+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 最近在喵神 onevcat 的直播中发现喵神直接在终端就能用 vsCode 打开当前代码目录，非常方便。</p>
<p> 在<code>zsh</code>终端中 使用 <code>code .</code>，在 <strong>vcCode</strong> 打开当前文件目录</p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdpxob9m7sj31000rkam7.jpg" alt=""></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="配置终端环境"><a href="#配置终端环境" class="headerlink" title="配置终端环境"></a>配置终端环境</h2><p>终端环境为：<a href="https://www.iterm2.com/" target="_blank" rel="external">iTerm2</a> + <a href="https://wiki.archlinux.org/index.php/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">zsh</a>)</p>
<p>zsh 使用 <a href="http://ohmyz.sh/" target="_blank" rel="external">oh_my_zsh</a> 配置</p>
<h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><h4 id="查看你的系统有几种shell"><a href="#查看你的系统有几种shell" class="headerlink" title="查看你的系统有几种shell"></a>查看你的系统有几种shell</h4><pre><code>cat /etc/shells
</code></pre><p>显示</p>
<pre><code>/bin/bash
/bin/csh
/bin/ksh
/bin/sh
/bin/tcsh
/bin/zsh
</code></pre><h4 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh my zsh"></a>安装 oh my zsh</h4><pre><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
</code></pre><p>重新打开终端，输入 </p>
<pre><code>zsh
</code></pre><p>即可切换终端，并且发现 oh my zsh 已经帮我们配置好 zsh 了</p>
<h4 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h4><pre><code>open ~/.zshrc 
</code></pre><p>修改 <code>ZSH_THEME=”robbyrussell”</code>，主题在 ~/.oh-my-zsh/themes 目录下。<br>修改为</p>
<pre><code>ZSH_THEME=&quot;kolo&quot;
</code></pre><p>可以<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="external">参照这里</a>进行选择.</p>
<h4 id="设置为默认shell"><a href="#设置为默认shell" class="headerlink" title="设置为默认shell"></a>设置为默认shell</h4><pre><code>chsh -s /bin/zsh
</code></pre><h2 id="修改-zsh-配置文件"><a href="#修改-zsh-配置文件" class="headerlink" title="修改 zsh 配置文件"></a>修改 <code>zsh</code> 配置文件</h2><pre><code>$ open ~/.zshrc
</code></pre><p>在文件中加上这几行代码</p>
<p>对应 atom、SublimeText、与 vcCode。</p>
<pre><code>alias atom=&apos;/Applications/Atom.app/Contents/MacOS/Atom&apos;
alias subl=&apos;/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl&apos;
alias code=&apos;/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code&apos;
</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>使用 vcCode 打开</p>
<pre><code>$ code .
</code></pre><blockquote>
<p>本文首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="external">BY Blog</a>, 作者 <a href="http://github.com/qiubaiying" target="_blank" rel="external">@柏荧(BY)</a> ,转载请保留原文链接.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/10/2017-03-10-CocoaPods私有仓库的创建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JimmyZhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jimmy'Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/10/2017-03-10-CocoaPods私有仓库的创建/" itemprop="url">CocoaPods私有仓库的创建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T00:00:00+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="external">BY Blog</a>、<a href="http://www.jianshu.com/p/d2d98298b1b8" target="_blank" rel="external">简书</a> 转载请保留链接</p>
<p>上一篇文章 <a href="http://qiubaiying.top/2017/03/08/CocoaPods公有仓库的创建/" target="_blank" rel="external">《CocoaPods公有仓库的创建》</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近参照了网上一大堆 CocoaPods私有仓库 的教程，按教程操作得到的pod仓库里面是这样的~</p>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fdgexnidglj30yq0eqn0r.jpg" alt=""></p>
<p>代码和版本描述居然混在了一起，简直太糟糕~</p>
<p>虽然也能用，但是和CocoaPods本身的结构设计就不相符。</p>
<p>在上一篇<a href="http://qiubaiying.top/2017/03/08/CocoaPods公有仓库的创建/" target="_blank" rel="external">《CocoaPods公有仓库的创建》</a>中我们了解到，<code>master</code> 目录中只存放 代码库 的描述文件，而不是存放代码。就像这样</p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fdgf4l54rxj30ya09ujst.jpg" alt=""></p>
<p>代码我们另外存放在代码仓库中</p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fdgf9t7vcgj30n206s0u8.jpg" alt=""></p>
<p>很多人不了解CocoaPods的工作原理就复制粘贴别人的教程来做教程~</p>
<p>吐槽结束，进入正文</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h4 id="创建版本库-repo"><a href="#创建版本库-repo" class="headerlink" title="创建版本库(repo)"></a>创建版本库(<strong>repo</strong>)</h4><p>首先，创建一个像 <code>master</code> 一样的存放版本描述文件的git仓库，因为是私人git仓库，我们选择 <a href="http://git.oschina.net/" target="_blank" rel="external">oschina</a> 创建远程私有仓库（因为是免费的）或者也可以在GitHub上创建（<strong>$7/month</strong>）。</p>
<p>下面以 <a href="http://git.oschina.net/" target="_blank" rel="external">oschina</a> 为例</p>
<p>创建版本描述仓库</p>
<p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fdgfqdqyy1j31kw1c2th0.jpg" alt=""></p>
<p>回到终端，将这个远程的私有版本仓库添加到本地，<code>repo</code> 就是 repository 储存库的缩写。</p>
<pre><code>$ pod repo add MyRepo https://git.oschina.net/baiyingqiu/MyRepo.git
</code></pre><p>查看在 Finder 目录 <code>~/.cocoapods/repos</code>， 可以发现增加了一个 MyRepo 的储存库</p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdgfyfl6v6j316y0piwhz.jpg" alt=""></p>
<h4 id="创建代码库"><a href="#创建代码库" class="headerlink" title="创建代码库"></a>创建代码库</h4><p>回到 <a href="http://git.oschina.net/" target="_blank" rel="external">oschina</a> 创建私人代码库</p>
<p>创建时添加 <code>MIT License</code> 和 <code>README</code></p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdgjfu7n96j31kw17y7cq.jpg" alt=""></p>
<p>将仓库克隆到本地，添加<code>你的代码文件</code>、<code>仓库名.podspec</code> 描述文件，还有<code>.swift-version</code>.</p>
<p>如下</p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdgmyefutej311a0kegqh.jpg" alt=""></p>
<p><code>.swift-version</code>文件用来知道swift版本，用命令行创建</p>
<pre><code>$ echo &quot;3.0&quot; &gt; .swift-version
</code></pre><p><strong><code>.podspec</code></strong> 文件是你这个代码库的pod描述文件,可以通过pod指令创建空白模板：</p>
<pre><code>$ pod spec create MyAdditions
</code></pre><p>或者 <strong>强烈建议</strong> 直接拷贝下面的模板进行修改</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></div><div class="line">  s.name         = <span class="string">"MyAdditions"</span> <span class="comment"># 项目名称</span></div><div class="line">  s.version      = <span class="string">"0.0.1"</span>        <span class="comment"># 版本号 与 你仓库的 标签号 对应</span></div><div class="line">  s.license      = <span class="string">"MIT"</span>          <span class="comment"># 开源证书</span></div><div class="line">  s.summary      = <span class="string">"私人pod代码"</span> <span class="comment"># 项目简介</span></div><div class="line"></div><div class="line">  s.homepage     = <span class="string">"https://git.oschina.net/baiyingqiu/MyAdditions"</span> <span class="comment"># 仓库的主页</span></div><div class="line">  s.source       = &#123; <span class="symbol">:git</span> =&gt; <span class="string">"https://git.oschina.net/baiyingqiu/MyAdditions.git"</span>, <span class="symbol">:tag</span> =&gt; <span class="string">"<span class="subst">#&#123;s.version&#125;</span>"</span> &#125;<span class="comment">#你的仓库地址，不能用SSH地址</span></div><div class="line">  s.source_files = <span class="string">"MyAdditions/*.&#123;h,m&#125;"</span> <span class="comment"># 你代码的位置， BYPhoneNumTF/*.&#123;h,m&#125; 表示 BYPhoneNumTF 文件夹下所有的.h和.m文件</span></div><div class="line">  s.requires_arc = <span class="literal">true</span> <span class="comment"># 是否启用ARC</span></div><div class="line">  s.platform     = <span class="symbol">:ios</span>, <span class="string">"7.0"</span> <span class="comment">#平台及支持的最低版本</span></div><div class="line">  <span class="comment"># s.frameworks   = "UIKit", "Foundation" #支持的框架</span></div><div class="line">  <span class="comment"># s.dependency   = "AFNetworking" # 依赖库</span></div><div class="line">  </div><div class="line">  <span class="comment"># User</span></div><div class="line">  s.author             = &#123; <span class="string">"BY"</span> =&gt; <span class="string">"qiubaiyingios@163.com"</span> &#125; <span class="comment"># 作者信息</span></div><div class="line">  s.social_media_url   = <span class="string">"http://qiubaiying.github.io"</span> <span class="comment"># 个人主页</span></div><div class="line"></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这里我要说一下一个坑，用 <a href="http://git.oschina.net/" target="_blank" rel="external">oschina</a> 创建私人仓库时, 在验证时可能会找不到 <code>MIT LICENSE</code>证书,将其中的</p>
<pre><code>s.license      = &quot;MIT&quot;
修改为，指定文件
s.license      = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; }
</code></pre><p>然后开始验证我们的仓库配置是否正确，并按照要求进行修改</p>
<pre><code>$ pod lib lint
</code></pre><p>一般出现错误警告，需要添加 <code>--private</code> 或者 <code>--allow-warnings</code>，就可以通过验证</p>
<pre><code>$ pod lib lint --private
</code></pre><p>验证成功后出现</p>
<pre><code> -&gt; MyAdditions (0.0.1)

MyAdditions passed validation.
</code></pre><h4 id="将描述文件推送到版本库"><a href="#将描述文件推送到版本库" class="headerlink" title="将描述文件推送到版本库"></a>将描述文件推送到版本库</h4><p>将项目打上标签推到远程仓库，标签号 和 版本号对应 都是<code>0.0.1</code></p>
<p>最后将我们的代码仓库的描述信息，push 到我们的版本仓库中</p>
<pre><code>$ pod repo push MyRepo MyAdditions.podspec
</code></pre><p>这时会对远程仓库进行验证，成功的话就会在 <code>~/.cocoapods/repos/MyRep</code>中发现新增的仓库描述信息了</p>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fdgo62knrwj31ko0s8784.jpg" alt=""></p>
<p>若是出现错误信息</p>
<pre><code>[!] The repo `MyRepo` at `../.cocoapods/repos/MyRepo` is not clean
</code></pre><p>更新下我们的版本库，</p>
<pre><code>$ pod repo update MyRepo
</code></pre><p>再继续上传即可。</p>
<p><code>pod repo push MyRepo MyAdditions.podspec</code> 的过程就是</p>
<ol>
<li>验证 <code>MyAdditions.podspec</code> 文件</li>
</ol>
<ul>
<li>拉取远程版本库 <code>MyRepo</code></li>
<li>添加 <code>MyAdditions.podspec</code> 到版本库中</li>
<li>push 到远程</li>
</ul>
<p>添加完成后我们就可以在pod中搜索</p>
<pre><code>$ pod search MyAdditions
</code></pre><hr>
<pre><code>-&gt; MyAdditions (0.0.1)
   Some category of the framework and UIKit
   pod &apos;MyAdditions&apos;, &apos;~&gt; 0.0.1&apos;
   - Homepage: https://git.oschina.net/baiyingqiu/MyAdditions
   - Source:   https://git.oschina.net/baiyingqiu/MyAdditions.git
   - Versions: 0.0.1 [MyRepo repo]
(END)
</code></pre><h3 id="私人pod库的使用"><a href="#私人pod库的使用" class="headerlink" title="私人pod库的使用"></a>私人pod库的使用</h3><p>使用私人pod库的需要在<code>Podflie</code>中添加这句话，指明你的版本库地址。</p>
<pre><code>source ‘https://git.oschina.net/baiyingqiu/MyRepo.git’
</code></pre><p><strong>注意</strong>是版本库的地址，而不是代码库的地址，很多教程都把我搞晕了~</p>
<p>若有还使用了公有的pod库，需要把公有库地址也带上</p>
<pre><code>source ‘https://github.com/CocoaPods/Specs.git’
</code></pre><p>最后的<code>Podflie</code>文件变成这个样子</p>
<pre><code>source ‘https://github.com/CocoaPods/Specs.git’
source ‘https://git.oschina.net/baiyingqiu/MyRepo.git’

platform :ios, &apos;8.0&apos;

target ‘MyPodTest’ do
use_frameworks!

pod “BYPhoneNumTF” #公有库
pod ‘MyAdditions’ #我们的私有库
pod ‘BYAdditions’ #这是我又添加到版本库中的另一个代码库

end
</code></pre><p>测试：</p>
<pre><code>$ pod install
</code></pre><p>加载完成可以看到代码已经整合到我们的项目中了</p>
<p><strong>perfect！</strong></p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fdhkgtfn98j30ee0hwq6y.jpg" width="250"></p>
<p>回到Fender中 <code>~/.cocoapods/repos</code>,会发现 repos 中增加了一个pod版本库。 </p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdhlc59rl9j30ya08y0ub.jpg" alt=""></p>
<p>执行 <code>pod install</code> 命令时</p>
<ul>
<li><p>会拉取远程 <code>Podflie</code> 中 <code>source</code> 标记 版本库 到本地的 repos 文件夹中</p>
</li>
<li><p>在 版本库 中搜索我们<code>pod ‘MyAdditions’</code> 的 <code>MyAdditions.podspec</code> 文件。</p>
</li>
<li>根据 <code>MyAdditions.podspec</code> 文件中描述的源码地址下载并整合到项目中</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过 <a href="http://qiubaiying.top/2017-03-10-CocoaPods私有仓库的创建/" target="_blank" rel="external">《CocoaPods私有仓库的创建》</a> 和 <a href="http://qiubaiying.top/2017/03/08/CocoaPods公有仓库的创建/" target="_blank" rel="external">《CocoaPods公有仓库的创建</a>》这两篇文章，相信大家对CocoaPods的工作原理都有了更深层次的了解。</p>
<p>在写博客和和创建的过程中，踩了不少的坑（😀前人教程留下的），很多的东西只有自己操作完才能真正的领会。</p>
<p>最后，如果本文有什么错误或者有什么不同的观点欢迎提出交流。😉</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/avatar.png"
              alt="JimmyZhao" />
          
            <p class="site-author-name" itemprop="name">JimmyZhao</p>
            <p class="site-description motion-element" itemprop="description">Jimmy | iOS | develop | 移动</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">45</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/JimmyZDD" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/yourname" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>Twitter</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JimmyZhao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
